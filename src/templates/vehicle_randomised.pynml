<!--! as of August 2024, this was simplified to
    - a 5/8 chance of getting the random bits from the engine (parent)
    - a 3/8 chance of using the random bits from the wagon (self)
    This produces promising results:
    - often has runs of similar vehicles within the consist
    - occasionally consists are very varied, or all one type
    - consists within groups tend to be very diverse
    This looked good to me and feedback on it was ok.
    -->

<tal:unit_variants repeat="unit_variant vehicle.unit_variants">
    switch (FEAT_TRAINS, SELF, ${unit_variant.id}_switch_graphics_variant_random_self,
                                random_bits_randomised_wagon_choose_wagon_self(
                                    0,
                                    ${len(consist.roster.get_wagon_randomisation_candidates(unit_variant.buyable_variant)).bit_length() - 1}
                                )
        ) {
        <tal:randomisation_candidates repeat="randomisation_candidate consist.roster.get_wagon_randomisation_candidates(unit_variant.buyable_variant)">
            ${repeat.randomisation_candidate.index}: ${repeat.randomisation_candidate.index};
        </tal:randomisation_candidates>
    }
    switch (FEAT_TRAINS, SELF, ${unit_variant.id}_switch_graphics_variant_random_parent,
                                random_bits_randomised_wagon_choose_wagon_parent(
                                    <tal:random_bits_offset switch="consist.gestalt_graphics.use_deterministic_random_vehicle_map">
                                        <!--! set an offset into engine bits, or not, as needed -->
                                        <tal:case case="True">
                                            random_bits_offset_from_deterministic_random_map(),
                                        </tal:case>
                                        <tal:case case="False">
                                            0,
                                        </tal:case>
                                    </tal:random_bits_offset>
                                    ${len(consist.roster.get_wagon_randomisation_candidates(unit_variant.buyable_variant)).bit_length() - 1}
                                )
        ) {
        <tal:randomisation_candidates repeat="randomisation_candidate consist.roster.get_wagon_randomisation_candidates(unit_variant.buyable_variant)">
            ${repeat.randomisation_candidate.index}: ${repeat.randomisation_candidate.index};
        </tal:randomisation_candidates>
    }
    <!--! note that the random chain is used by both graphics and colour mapping chains -->
    switch (FEAT_TRAINS, SELF, ${unit_variant.id}_switch_graphics_variant_choose_randomised_wagon, random_bits_randomised_wagon_check_parent_or_self()) {
        <tal:optional_bits_from_self condition="not:consist.gestalt_graphics.use_deterministic_random_vehicle_map">
            0..2: ${unit_variant.id}_switch_graphics_variant_random_self;
        </tal:optional_bits_from_self>
        ${unit_variant.id}_switch_graphics_variant_random_parent;
    }

    switch (FEAT_TRAINS, SELF, ${unit_variant.id}_switch_graphics_variant, ${unit_variant.id}_switch_graphics_variant_choose_randomised_wagon()) {
        <tal:randomisation_candidates repeat="randomisation_candidate consist.roster.get_wagon_randomisation_candidates(unit_variant.buyable_variant)">
            ${repeat.randomisation_candidate.index}: ${randomisation_candidate.unit.id}_switch_graphics;
        </tal:randomisation_candidates>
    }

    // buy menu graphics chain
    spriteset(${unit_variant.id}_ss_purchase, "${graphics_path}${consist.id}.png") {
        ${consist.get_nml_for_spriteset_template(y_offset=0)}
    }
    <!--! handle colour mapping which can vary per buyable variant
          note that we have to make the same random choice here as the graphics chain, so we delegate to a shared procedure -->
    switch (FEAT_TRAINS, SELF, ${unit_variant.id}_switch_colour_mapping_variant, ${unit_variant.id}_switch_graphics_variant_choose_randomised_wagon()) {
        <tal:randomisation_candidates repeat="randomisation_candidate consist.roster.get_wagon_randomisation_candidates(unit_variant.buyable_variant)">
            ${repeat.randomisation_candidate.index}:return switch_colour_mapping(
                ${randomisation_candidate.get_wagon_recolour_strategy_params()},
            );
        </tal:randomisation_candidates>
    }
    switch (FEAT_TRAINS, SELF, ${unit_variant.id}_switch_colour_mapping_variant_purchase, ${unit_variant.id}_switch_graphics_variant_choose_randomised_wagon()) {
        <tal:randomisation_candidates repeat="randomisation_candidate consist.roster.get_wagon_randomisation_candidates(unit_variant.buyable_variant)">
            ${repeat.randomisation_candidate.index}:return switch_colour_mapping(
                ${randomisation_candidate.get_wagon_recolour_strategy_params(context="purchase")},
            );
        </tal:randomisation_candidates>
    }
</tal:unit_variants>

<!--! note that we provide '_switch_graphics' not '_switch_graphics_vehicle' as there are no precursor graphics entry switches for randomised wagons
      we'll ultimately chain instead to the selected candidate's graphics entry switch -->
switch (FEAT_TRAINS, SELF, ${vehicle.id}_switch_graphics, vehicle_type_id) {
    <tal:unit_variants repeat="unit_variant vehicle.unit_variants">
        ${unit_variant.numeric_id}: ${unit_variant.id}_switch_graphics_variant;
    </tal:unit_variants>
    <!--! no default, by design all variants should be explicitly found -->
}
<!--! purchase sprites always go through a switch in case the template does anything specific for purchase graphics
      when there is nothing specific, then this is just a null switch -->
switch (FEAT_TRAINS, SELF, ${vehicle.id}_switch_graphics_purchase, vehicle_type_id) {
    <tal:unit_variants repeat="unit_variant vehicle.unit_variants">
        ${unit_variant.numeric_id}: ${unit_variant.id}_ss_purchase;
    </tal:unit_variants>
    <!--! no default, by design all variants should be explicitly found -->
}

switch (FEAT_TRAINS, SELF, ${vehicle.id}_switch_colour_mapping, vehicle_type_id) {
    <tal:unit_variants repeat="unit_variant vehicle.unit_variants">
        ${unit_variant.numeric_id}: ${unit_variant.id}_switch_colour_mapping_variant;
    </tal:unit_variants>
    <!--! no default, by design all variants should be explicitly found -->
}
switch (FEAT_TRAINS, SELF, ${vehicle.id}_switch_colour_mapping_purchase, vehicle_type_id) {
    <tal:unit_variants repeat="unit_variant vehicle.unit_variants">
        ${unit_variant.numeric_id}: ${unit_variant.id}_switch_colour_mapping_variant_purchase;
    </tal:unit_variants>
    <!--! no default, by design all variants should be explicitly found -->
}

<!--! note that graphics_entry_switches.pynml shouldn't be called as a macro here
      randomised vehicles chain via the selected candidate's graphics entry switch, so they don't need their own graphics entry switch  -->

<tal:include metal:use-macro="load: capacity.pynml" />

<tal:include metal:use-macro="load: properties.pynml" />
